/*! \mainpage
*\section one Основні зміни, що були зроблені в коді
*
*Серед змін, зроблених в коді цієї програми, є ширше застосування принципів ООП, застосування патернів, перебудова коду згідно з орієнтацією на принципи DRY,KISS,YAGNI та SOLID.
*
*
*
*\section two Застосування принципів ООП
*
*З метою поліпшення коду для розуміння було звернено увагу на головні принципи ООП: інкапсуляцію, наслідування та поліморфізм.
*Окрім очевидного застосування інкапсуляції (майже всі класи містять в собі приватні поля та методи для взаємодії з ними), частішим стало використання поліморфізму та наслідування.
*Поліморфізм набуває форми як статичного, так і динамічного типу. Прикладом статичного є метод MainWindow::removeSelectedItem (див. @ref MainWindow  ) або ж
*windowofgroups::receiveData(див. @ref windowofgroups  ). Динамічний тип застосований при створенні таких методів, як MainWindow::deleteItemNoSignal (див. @ref MainWindow  ) або ж методи класу
* @ref readerofnotes.
*
* З'явилася більша кількість випадків використання наслідування, зокрема цим користуються такі класи, як @ref MainWindow , @ref archivewindow , @ref concretememento та інші.
*
*
*\section three Патерни
*
*З метою надання гнучкості класу, який виконує функцію зчитування даних з файлів (див. @ref initfilereader ), було використано патерн "Template Method". Згідно з цим патерном, було
*створено зразковий метод @ref initfilereader::readFromFile та розділено його на окремі методи, які можуть бути перебудованими відповідно до потреб окремих класів. Ця можливість
* використана при утворенні двох класів @ref readerofnotes та @ref readerofgroups.
*
*Патерн "Memento", який надає алгоритм для побудови коду для реалізації зручного зберігання та відновлення попередніх станів об'єкта, був використаним при створенні функціоналу,
*який дозволяє користувачу скасувати свої попередні дії над списком та його елементами (див. editinghistory.h ). Цей функціонал був окремо винесеним в бібліотеку.
*
* \section four Принципи DRY,KISS,YAGNI та SOLID
*
* \subsection DRY
*
*Код програми для нотатків частково притримується цього принципу. Зокрема, замість повторного написання однакових методів зчитування даних з файлів було створено файл filereader.h ,
*який містить класи, відповідальні за втілення цієї функції, які використовують @ref MainWindow , @ref archivewindow та @ref windowofgroups . Разом з цим були переписаними деякі методи,
*які були раніше створені з повторним використанням кодів інших методів або були занадто специфічними та не універсальними
*(наприклад, замість методу saveToArchive, який зберігав потрібний об'єкт типу QListWidgetItem* до архіву, було
*створено більш універсальний метод saveItem, який зберігає обраний об'єкт до обраного файлу)
*
*Були створені окремі змінні для повторно використовуваних значень (приклад наведений в наступному параграфі).
*\subsection KISS
*
*Ідея редагування вихідного коду задля спрощення його розуміння та використання, була втілена у змінах назв об'єктів на більш описові (наприкад, назва класу secondwindow було змінено на archivewindow ,
*listWidget було змінено на listofnotes тощо), були створені окремі змінні для повторно використовуваних значень (наприклад, в коді були прибрані прямі використання назв файлів, натомість
*були створені такі змінні, як @ref initfilereader::NameOfNotes, @ref::NameOfArchive тощо).
*
*У виборі між простішими для розуміння та роботи структурами та складнішими, проте більш функціональними, іноді надавалась перевага першим, наприклад, між QListWidget та Model/View
* був обраним саме перший варіант
*
*\subsection YAGNI
*
*Відхилення від цього принципу зустрічалися досить рідко в старому коді, тож значних змін в цьому напрямку не було. Серед полей та методів класів, за винятком одиничних випадків, немає тих,
*які б не використовувалися у ході виконання програми.
*
*Додавання нових можливостей програми відбувається поступово за необхідності шляхом створення нових класів та методів.
*
*
*\subsection SOLID
*
*\subsubsection first Single-Responsibility Principle
*
*Вихідний код в певному значенні притримувався цього принципу: класи поділяли між собою функціональність програми, залежно від їх типів: для роботи з усіма нотатками та групами використовувався
*клас @ref MainWindow з відповідними методами, для роботи виключно з архівом - @ref archivewindow , завдання вибору групи для копіювання та переміщення нотатки брав на себе клас @ref windowofgroup. Проте
*велика кількість методів містила в собі багато приводів для змін, наприклад, у випадку зміни формату або назви файлів їх потрібно було б змінювати у кожному з методів,
*в якому відбувалась робота з файлами (те саме стосується текстів повідомлень про помилку).
*
*В оновленій версії коду ці помилки принципу єдиної відповідальності були здебільшого виправлені: надається перевага більшій кількості методів, які б брали на себе відповідальність
*за окрему функцію, яку виконують. Окрім вище згаданих речей, можна назвати ще й викоремлений в окремий клас функціонал читання файлів (див. @ref initfilereader), методи якого розділяють є
*втіленням принципу єдиної відповідальності.
*
*\subsubsection second Open-Closed Principle
*
* В початковій версії коду цей принцип загалом оминався. В оновленій версії, завдяки відокремленню реалізації функціоналу від основних класів (@ref MainWindow , @ref archivewindow , @ref windowofgroups),
* з'явилася більша кількість класів, які "відкриті" до застосування цього принципу, наприклад, @ref readerofnotes , @ref readerofgroups , @ref concretememento тощо. Такі класи відкриті
*до розширення та закриті до модифікацій, що робить їх використання гнучким та універсальним.
*
*\subsubsection third Liskov Substitution Principle
*
*Не використовувався в початковій версії коду, не набув практичного застосування в цій програмі з оновленою версією.
*
*\subsubsection fourth Interface Segregation Principle
*
*Не використовувався в початковій версії коду. В оновленій версії набув вжитку з використанням віртуальних класів. Віртуальні класи розділені згідно з їхніми спеціалізаціями.
* Випадки, коли потрібно реалізовувати непотрібний абстрактний клас або віртуальний метод, трапляються вкрай рідко. Приклади класів, які
*демонструють цей принцип: @ref initfilereader , @ref readerofnotes  та @ref readerofgroups
*
*\subsubsection fifth  Dependency Inversion Principle
*
*В попередній версії не використовувалося наслідування абстрактних класів. В оновленій версії з використанням абстрактних класів набув вжитку цей принцип, хоч і з деякими порушеннями через
* використання патерну. Його застосування
*продемонстровано на прикладі класів @ref initfilereader , @ref readerofnotes (абстрактний) та @ref readerofgroups або @ref memento (абстрактний)  та @ref concretememento .
*Основним порушенням цього принципу у випадки перших трьох названих класів є конкретна імплементація в абстрактному класі. В двох останніх названих класах такого порушення немає.
*
*
*
*
*
*
*
*/
